{"version":3,"sources":["../../src/csv-loader.js"],"names":["AsyncQueue","TableBatchBuilder","RowTableBatch","Papa","AsyncIteratorStreamer","VERSION","CSVLoaderOptions","csv","TableBatch","batchSize","header","rowFormat","columnPrefix","quoteChar","escapeChar","dynamicTyping","comments","skipEmptyLines","delimitersToGuess","id","name","version","extensions","mimeTypes","category","parse","arrayBuffer","options","parseCSV","TextDecoder","decode","parseText","parseInBatches","parseCSVInBatches","testText","csvText","hasHeader","config","download","error","e","Error","result","data","asyncIterator","TableBatchType","asyncQueue","convertToObject","isFirstRow","headerRow","tableBatchBuilder","schema","step","results","parser","row","bytesUsed","meta","cursor","isHeaderRow","i","length","deduceSchema","addRow","isFull","enqueue","getBatch","complete","file","batch","close","Boolean","every","value","Promise","resolve","reject","abort","columnName","String","index","type","Float32Array","Array"],"mappings":"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","sourcesContent":["/* global TextDecoder */\nimport {AsyncQueue, TableBatchBuilder, RowTableBatch} from '@loaders.gl/tables';\nimport Papa from './libs/papaparse';\nimport AsyncIteratorStreamer from './lib/async-iterator-streamer';\n/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nconst CSVLoaderOptions = {\n  csv: {\n    TableBatch: RowTableBatch,\n    batchSize: 10,\n    // CSV options\n    header: 'auto',\n    rowFormat: 'auto',\n    columnPrefix: 'column',\n    // delimiter: auto\n    // newline: auto\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: false,\n    // transform: null?\n    delimitersToGuess: [',', '\\t', '|', ';']\n    // fastMode: auto\n  }\n};\n\n/** @type {LoaderObject} */\nexport default {\n  id: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv'],\n  mimeTypes: ['text/csv'],\n  category: 'table',\n  parse: async (arrayBuffer, options) => parseCSV(new TextDecoder().decode(arrayBuffer), options),\n  parseText: parseCSV,\n  parseInBatches: parseCSVInBatches,\n  testText: null,\n  options: CSVLoaderOptions\n};\n\nasync function parseCSV(csvText, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoaderOptions, ...options};\n  options.csv = {...CSVLoaderOptions.csv, ...options.csv};\n\n  const header = await hasHeader(csvText, options);\n\n  const config = {\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings\n    ...options.csv,\n    header,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    error: e => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, config);\n  return result.data;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(asyncIterator, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoaderOptions, ...options};\n  options.csv = {...CSVLoaderOptions.csv, ...options.csv};\n\n  const {batchSize} = options.csv;\n  const TableBatchType = options.csv.TableBatch;\n\n  const asyncQueue = new AsyncQueue();\n\n  const convertToObject = options.csv.rowFormat === 'object';\n\n  let isFirstRow = true;\n  let headerRow = null;\n  let tableBatchBuilder = null;\n  let schema = null;\n\n  const config = {\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings,\n    ...options.csv,\n    header: false, // Unfortunately, header detection is not automatic and does not infer types\n    download: false, // We handle loading, no need for papaparse to do it for us\n    // chunk(results, parser) {\n    //   // TODO batch before adding to queue.\n    //   console.log('Chunk:', results, parser);\n    //   asyncQueue.enqueue(results.data);\n    // },\n\n    // step is called on every row\n    step(results, parser) {\n      const row = results.data;\n      const bytesUsed = results.meta.cursor;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        // Auto detects or can be forced with options.csv.header\n        const header = isHeaderRow(row, options);\n        if (header) {\n          headerRow = row;\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = [];\n          for (let i = 0; i < row.length; i++) {\n            headerRow[i] = `${options.csv.columnPrefix}${i + 1}`;\n          }\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder ||\n        new TableBatchBuilder(TableBatchType, schema, {batchSize, convertToObject});\n\n      tableBatchBuilder.addRow(row);\n      // If a batch has been completed, emit it\n      if (tableBatchBuilder.isFull()) {\n        asyncQueue.enqueue(tableBatchBuilder.getBatch({bytesUsed}));\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results, file) {\n      const bytesUsed = results.meta.cursor;\n      // Ensure any final (partial) batch gets emitted\n      const batch = tableBatchBuilder.getBatch({bytesUsed});\n      if (batch) {\n        asyncQueue.enqueue(batch);\n      }\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\nfunction isHeaderRow(row, options) {\n  if (options && options.csv.header !== 'auto') {\n    return Boolean(options.csv.header);\n  }\n\n  return row.every(value => typeof value === 'string');\n}\n\nasync function hasHeader(csvText, options) {\n  if (options.csv.header !== 'auto') {\n    return Boolean(options.csv.header);\n  }\n\n  return await new Promise((resolve, reject) => {\n    Papa.parse(csvText, {\n      download: false,\n      dynamicTyping: true,\n      step: (results, parser) => {\n        parser.abort();\n        const row = results.data;\n        // Test the row\n        resolve(isHeaderRow(row));\n      },\n      error: e => {\n        reject(new Error(e));\n      }\n    });\n  });\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n"],"file":"csv-loader.js"}