{"version":3,"sources":["../../src/csv-loader.js"],"names":["VERSION","CSVLoaderOptions","csv","TableBatch","RowTableBatch","batchSize","header","rowFormat","columnPrefix","quoteChar","escapeChar","dynamicTyping","comments","skipEmptyLines","delimitersToGuess","id","name","version","extensions","mimeTypes","category","parse","arrayBuffer","options","parseCSV","TextDecoder","decode","parseText","parseInBatches","parseCSVInBatches","testText","csvText","hasHeader","config","download","error","e","Error","result","Papa","data","asyncIterator","TableBatchType","asyncQueue","AsyncQueue","convertToObject","isFirstRow","headerRow","tableBatchBuilder","schema","step","results","parser","row","bytesUsed","meta","cursor","isHeaderRow","i","length","deduceSchema","TableBatchBuilder","addRow","isFull","enqueue","getBatch","complete","file","batch","close","AsyncIteratorStreamer","Boolean","every","value","Promise","resolve","reject","abort","columnName","String","index","type","Float32Array","Array"],"mappings":"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","sourcesContent":["/* global TextDecoder */\nimport {AsyncQueue, TableBatchBuilder, RowTableBatch} from '@loaders.gl/tables';\nimport Papa from './libs/papaparse';\nimport AsyncIteratorStreamer from './lib/async-iterator-streamer';\n/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nconst CSVLoaderOptions = {\n  csv: {\n    TableBatch: RowTableBatch,\n    batchSize: 10,\n    // CSV options\n    header: 'auto',\n    rowFormat: 'auto',\n    columnPrefix: 'column',\n    // delimiter: auto\n    // newline: auto\n    quoteChar: '\"',\n    escapeChar: '\"',\n    dynamicTyping: true,\n    comments: false,\n    skipEmptyLines: false,\n    // transform: null?\n    delimitersToGuess: [',', '\\t', '|', ';']\n    // fastMode: auto\n  }\n};\n\n/** @type {LoaderObject} */\nexport default {\n  id: 'csv',\n  name: 'CSV',\n  version: VERSION,\n  extensions: ['csv'],\n  mimeTypes: ['text/csv'],\n  category: 'table',\n  parse: async (arrayBuffer, options) => parseCSV(new TextDecoder().decode(arrayBuffer), options),\n  parseText: parseCSV,\n  parseInBatches: parseCSVInBatches,\n  testText: null,\n  options: CSVLoaderOptions\n};\n\nasync function parseCSV(csvText, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoaderOptions, ...options};\n  options.csv = {...CSVLoaderOptions.csv, ...options.csv};\n\n  const header = await hasHeader(csvText, options);\n\n  const config = {\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings\n    ...options.csv,\n    header,\n    download: false, // We handle loading, no need for papaparse to do it for us\n    error: e => {\n      throw new Error(e);\n    }\n  };\n\n  const result = Papa.parse(csvText, config);\n  return result.data;\n}\n\n// TODO - support batch size 0 = no batching/single batch?\nfunction parseCSVInBatches(asyncIterator, options) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...CSVLoaderOptions, ...options};\n  options.csv = {...CSVLoaderOptions.csv, ...options.csv};\n\n  const {batchSize} = options.csv;\n  const TableBatchType = options.csv.TableBatch;\n\n  const asyncQueue = new AsyncQueue();\n\n  const convertToObject = options.csv.rowFormat === 'object';\n\n  let isFirstRow = true;\n  let headerRow = null;\n  let tableBatchBuilder = null;\n  let schema = null;\n\n  const config = {\n    dynamicTyping: true, // Convert numbers and boolean values in rows from strings,\n    ...options.csv,\n    header: false, // Unfortunately, header detection is not automatic and does not infer types\n    download: false, // We handle loading, no need for papaparse to do it for us\n    // chunk(results, parser) {\n    //   // TODO batch before adding to queue.\n    //   console.log('Chunk:', results, parser);\n    //   asyncQueue.enqueue(results.data);\n    // },\n\n    // step is called on every row\n    step(results, parser) {\n      const row = results.data;\n      const bytesUsed = results.meta.cursor;\n\n      // Check if we need to save a header row\n      if (isFirstRow && !headerRow) {\n        // Auto detects or can be forced with options.csv.header\n        const header = isHeaderRow(row, options);\n        if (header) {\n          headerRow = row;\n          return;\n        }\n      }\n\n      // If first data row, we can deduce the schema\n      if (isFirstRow) {\n        isFirstRow = false;\n        if (!headerRow) {\n          headerRow = [];\n          for (let i = 0; i < row.length; i++) {\n            headerRow[i] = `${options.csv.columnPrefix}${i + 1}`;\n          }\n        }\n        schema = deduceSchema(row, headerRow);\n      }\n\n      // Add the row\n      tableBatchBuilder =\n        tableBatchBuilder ||\n        new TableBatchBuilder(TableBatchType, schema, {batchSize, convertToObject});\n\n      tableBatchBuilder.addRow(row);\n      // If a batch has been completed, emit it\n      if (tableBatchBuilder.isFull()) {\n        asyncQueue.enqueue(tableBatchBuilder.getBatch({bytesUsed}));\n      }\n    },\n\n    // complete is called when all rows have been read\n    complete(results, file) {\n      const bytesUsed = results.meta.cursor;\n      // Ensure any final (partial) batch gets emitted\n      const batch = tableBatchBuilder.getBatch({bytesUsed});\n      if (batch) {\n        asyncQueue.enqueue(batch);\n      }\n      asyncQueue.close();\n    }\n  };\n\n  Papa.parse(asyncIterator, config, AsyncIteratorStreamer);\n\n  // TODO - Does it matter if we return asyncIterable or asyncIterator\n  // return asyncQueue[Symbol.asyncIterator]();\n  return asyncQueue;\n}\n\nfunction isHeaderRow(row, options) {\n  if (options && options.csv.header !== 'auto') {\n    return Boolean(options.csv.header);\n  }\n\n  return row.every(value => typeof value === 'string');\n}\n\nasync function hasHeader(csvText, options) {\n  if (options.csv.header !== 'auto') {\n    return Boolean(options.csv.header);\n  }\n\n  return await new Promise((resolve, reject) => {\n    Papa.parse(csvText, {\n      download: false,\n      dynamicTyping: true,\n      step: (results, parser) => {\n        parser.abort();\n        const row = results.data;\n        // Test the row\n        resolve(isHeaderRow(row));\n      },\n      error: e => {\n        reject(new Error(e));\n      }\n    });\n  });\n}\n\nfunction deduceSchema(row, headerRow) {\n  const schema = headerRow ? {} : [];\n  for (let i = 0; i < row.length; i++) {\n    const columnName = (headerRow && headerRow[i]) || i;\n    const value = row[i];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n  }\n  return schema;\n}\n"],"file":"csv-loader.js"}