# -*- coding: utf-8 -*-
"""FireModel_mesa.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h4VIAr0c-kP5Z6t_ZjaVd9JlejQb95qF
"""

import os
import sys
import matplotlib.pyplot as plt
from osgeo import gdal_array
import numpy as np
import pandas as pd
import geopandas as gpd
import shapely
from shapely.geometry import box
import random
from PIL import Image
from matplotlib.pyplot import imshow
from mesa import Model, Agent
from mesa.time import RandomActivation
from mesa.space import Grid
from mesa.datacollection import DataCollector
from mesa.batchrunner import BatchRunner
from mesa_geo import GeoSpace, GeoAgent, AgentCreator

# pip install Pillow
# pip install descartes
# conda install fiona pyproj rtree shapely
# pip install mesa-geo
# pip install PyDrive

path = '/Users/alex/Google Drive/05_Sync/FFE/Mesa'

# crop data
minx, miny = 1748347, 5426740
maxx, maxy = 1749151, 5427195
bbox = box(minx, miny, maxx, maxy)

gdf_buildings = gpd.read_file(os.path.join(path, "buildings_raw.shp"), bbox=bbox)
gdf_buildings.plot()

# wind scenario
wind = pd.read_csv(os.path.join(path, 'GD_wind.csv'))

def wind_scenario(wind_data=wind):
    i = np.random.randint(0, wind_data.shape[0])
    wind = wind_data.iloc[i, 2]
    distance = wind_data.iloc[i, 1]
    return wind, distance


class Building(Agent):
    '''

        condition: Can be "Fine", "On Fire", or "Burned Out"

    unique_id isn't strictly necessary here, but it's good practice to give one to each
    agent anyway.
    '''

    def __init__(self, model, pos):
        '''
        Create a new tree.
        Args:
            pos: The tree's coordinates on the grid. Used as the unique_id
        '''
        super().__init__(pos, model)
        self.pos = pos
        self.unique_id = pos
        self.condition = "Fine"

    def step(self):
        '''
        If the building is on fire, spread it to fine buildings nearby.
        '''
        if self.condition == "On Fire":
            neighbors = self.model.grid.get_neighbors(self.pos, moore=True, radius=12)
            for neighbor in neighbors:
                if neighbor.condition == "Fine":
                    neighbor.condition = "On Fire"
            self.condition = "Burned Out"


class WellyFire(Model):
    '''
    Simple city Fire model.
    '''

    def __init__(self):
        '''
        Create a new city fire model.

        Args:
            height, width: The size of the grid to model
            density: What fraction of grid cells have a tree in them.
        '''
        # Initialize model parameters
        self.grid = GeoSpace()
        buildings_agent_kwargs = dict(model=self)
        ac = AgentCreator(agent_class=Building, agent_kwargs=buildings_agent_kwargs, )
        agents = ac.from_GeoDataFrame(gdf_buildings, unique_id="TARGET_FID")
        self.grid.add_agents(agents)

        # Set up model objects
        self.schedule = RandomActivation(self)
        self.dc = DataCollector({"Fine": lambda m: self.count_type(m, "Fine"),
                                 "On Fire": lambda m: self.count_type(m, "On Fire"),
                                 "Burned Out": lambda m: self.count_type(m, "Burned Out")})

        # Place a tree in each cell with Prob = density
        for a in agents:
            if random.random() < a.IgnProb_bl:
                a.condition = "On Fire"
        self.running = True

    def step(self):
        '''
        Advance the model by one step.
        '''
        self.schedule.step()
        self.dc.collect(self)
        # Halt if no more fire
        if self.count_type(self, "On Fire") == 0:
            self.running = False

    @staticmethod
    def count_type(model, tree_condition):
        '''
        Helper method to count trees in a given condition in a given model.
        '''
        count = 0
        for tree in model.schedule.agents:
            if tree.condition == tree_condition:
                count += 1
        return count


fire = WellyFire()
fire.run_model()

# plot output
results = fire.dc.get_model_vars_dataframe()
results.plot()

# batch run
param_set = dict(height=50, # Height and width are constant
                 width=50,
                 # Vary density from 0.01 to 1, in 0.01 increments:
                 density=np.linspace(0,1,101)[1:])
# At the end of each model run, calculate the fraction of trees which are Burned Out
model_reporter = {"BurnedOut": lambda m: (WellyFire.count_type(m, "Burned Out") /
                                          m.schedule.get_agent_count()) }
# Create the batch runner
param_run = BatchRunner(WellyFire, param_set, model_reporters=model_reporter, iterations=5)
param_run.run_all()

# output
df = param_run.get_model_vars_dataframe()
df.head()
plt.hist(df.BurnedOut)